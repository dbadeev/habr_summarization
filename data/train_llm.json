[{"request": "Тестируйте API, как профессионал. Часть 2: Как автоматизировать API с помощью 'cypress-plugin-api' / Хабр                 \n\ncypress-plugin-api  , написанный амбассадором Cypress  Филипом Хриком  (Filip Hric), представляет собой плагин для эффективного тестирования API. Представьте себе Postman, но в Cypress; этот плагин выводит на печать всю информацию о вызове API в пользовательском интерфейсе приложения Cypress, обеспечивая несколько преимуществ:\n\nВ  `cypress-plugin-api`  команда  `cy.api()`  работает также как  `cy.request()`  . Основное отличие заключается в том, что помимо вызова вашего API,  `cy.api()`  также печатает информацию о вызове API в вашем Cypress Test Runner.\n\n Всю эту информацию можно просмотреть в виде  time-travel  (реверсивная отладка) snapshots.\n\n Также формируется простая таблица для просмотра файлов cookie, сворачивания объектов данных JSON и массива, а также цветового кодирования методов в представлении пользовательского интерфейса и на таймлайне (временной шкале)\n\n_Самое важное:_  `cy.api()`  использует  `cy.request()`  в фоновом режиме. Это означает, что вы получаете ту же функциональность плюс визуальный пользовательский интерфейс!\n\n### Давайте вместе установим плагин cypress-plugin-api ###\n\n**Шаг 1**\n\nУстновите  плагин,  используя npm или yarn.\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnpm i cypress-plugin-api\n# or\nyarn add cypress-plugin-api\n\n```\n\nПосле установки плагина API вы можете увидеть его в файле package.json:\n\n**Шаг 2**\n\nДалее добавьте плагин   `cypress/support/e2e.js`  в файл:\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timport 'cypress-plugin-api'\n// or\nrequire('cypress-plugin-api')\n\n```\n\nВаши e2e.js файлы будут выглядеть так:\n\n**Шаг 3**\n\nСоздайте плагин  `cypress_plugin_api.cy.js`  с помощью методов (GET, POST, PUT, DELETE).\n\nДля данного обзора я беру различные примеры методов API из этого ресурса:  https://reqres.in/  .\n\n**GET Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"GET API testing Using Cypress API Plugin\", () => {\n cy.api(\"GET\", \"https://reqres.in/api/users?page=2\").should((response) => {\n   expect(response.status).to.eq(200);\n });\n});\n\n```\n\n**POST Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"POST API testing Using Cypress API Plugin\", () => {\n cy.api(\"POST\", \"https://reqres.in/api/users\", {\n   name: \"morpheus\",\n   job: \"leader\",\n }).should((response) => {\n   expect(response.status).to.eq(201);\n });\n});\n\n```\n\n**PUT Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"PUT API testing Using Cypress API Plugin\", () => {\n cy.api(\"PUT\", \"https://reqres.in/api/users/2\", {\n   name: \"morpheus\",\n   job: \"zion resident\",\n }).should((response) => {\n   expect(response.status).to.eq(200);\n });\n});\n\n```\n\n**DELETE Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"DELETE API testing Using Cypress API Plugin\", () => {\n cy.api(\"DELETE\", \"https://reqres.in/api/users/2\").should((response) => {\n   expect(response.status).to.eq(204);\n });\n});\n\n```\n\n### Отчет о выполнении тестового кейса API ###\n\nНа скриншоте ниже мы видим данные Body, Response, Headers и Cookies, отображенные в пользовательском интерфейсе приложения Cypress. Ранее для просмотра этой информации нам приходилось нажимать на кнопку 'inspect', но теперь у нас есть пользовательский интерфейс, который позволяет нам легко получить к ней доступ.\n\n**GET Запрос**\n\n**POST Запрос**\n\n**PUT Запрос**\n\n**DELETE Запрос**\n\nВ завершение приглашаем всех желающих на открытый урок «Автоматизация API + удобные отчеты», который пройдет 24 марта в преддверии старта курса \"JavaScript QA Engineer\".\n\nЗаписаться на бесплатный урок\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "cypress-plugin-api - это плагин для эффективного тестирования API, написанный амбассадором Cypress Филипом Хриком. Он предоставляет визуальный пользовательский интерфейс для просмотра информации о вызовах API, включая время, файлы cookie, методы и данные.\n\nДля использования cypress-plugin-api необходимо установить его с помощью npm или yarn, а затем добавить в файл e2e.js. Затем можно создавать плагины cypress_plugin_api.cy.js для различных методов API, таких как GET, POST, PUT и DELETE.\n\nВ статье приведены примеры использования cypress-plugin-api для тестирования различных методов API с использованием Cypress. Отчет о выполнении тестового кейса API включает данные о Body, Response, Headers и Cookies, которые отображаются в пользовательском интерфейсе Cypress.\n\nТакже в статье предлагается бесплатный открытый урок по автоматизации API и созданию удобных отчетов, который пройдет 24 марта."}, {"request": "clipped() не оказывает влияния на проверку касаний / Хабр                 \n\nМодификатор  clipped()  в SwiftUI обрезает вью до своих(модификатора) границ, скрывая все, что выходит за пределы этих границ. Но обратите внимание, что обрезание не влияет на проверку касаний (hit testing); обрезанный вью по-прежнему принимает тапы / клики за пределами видимой области.\n\nПротестировано на iOS 16.1 и macOS 13.0.\n\n## Пример ##\n\nУ нас есть квадрат 300×300, который затем мы ограничиваем кадром 100×100. Также добавим границу вокруг внешней рамки, чтобы визуализировать вью:\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRectangle ()\n  .fill(.orange.gradient)\n  .frame(width: 300 , height: 300 )\n  // Set view to 100×100 → renders out of bounds\n  .frame(width: 100 , height: 100 )\n  .border(.blue)\n\n```\n\nВьюшки в SwiftUI по умолчанию не обрезают свой контент, поэтому весь квадрат размером 300×300 остается видимым. Обратите внимание на синюю рамку, обозначающую границы кадра 100×100:\n\nТеперь давайте добавим  **.clipped()**  ,\n\n чтобы обрезать большой квадрат до кадра 100×100. Я также сделал квадрат\n\n кликабельным и добавил кнопку:\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVStack  {\n  Button ( \"You can't tap me!\" ) {\n    buttonTapCount += 1\n  }\n  .buttonStyle(.borderedProminent)\n\n  Rectangle ()\n    .fill(.orange.gradient)\n    .frame(width: 300 , height: 300 )\n    .frame(width: 100 , height: 100 )\n    .clipped()\n    .onTapGesture {\n      rectTapCount += 1\n    }\n}\n\n```\n\nКогда вы запустите этот код, вы обнаружите, что кнопка не нажимается совсем. Это связано с тем, что (необрезанный) квадрат, несмотря на то, что он виден не полностью, закрывает(затеняет) эту кнопку и «крадет» все нажатия.\n\nПунктирная линия обозначает область нажатия для оранжевого квадрата. Кнопку нельзя нажать, т.к. она закрыта обрезанным вью относительно к hit testing.\n\n## Решение: .contentShape() ##\n\nМодификатор  contentShape(\\_:)  определяет область проверки\n\n касания для вью. Добавляя  **.contentShape(Rectangle())**  к кадру 100×100, мы ограничиваем проверку касания\n\n этой областью, делая кнопку снова доступной для нажатия:\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRectangle ()\n    .fill(.orange.gradient)\n    .frame(width: 300 , height: 300 )\n    .frame(width: 100 , height: 100 )\n    .contentShape( Rectangle ())\n    .clipped()\n\n```\n\nОбратите внимание, что порядок  **.contentShape(Rectangle())**  и  **.clipped()**  можно поменять местами. Важно то, что  **contentShape**  является (косвенным) родителем модификатора кадра 100×100, который определяет размер области проверки касания.\n\n## Видео ##\n\nЯ сделал короткое видео, демонстрирующее эффект:\n\nПервоначально нажатия на кнопку или даже на окружающее пустое пространство регистрируются как нажатия на квадрат.\n\n Верхний переключатель дает нам увидеть квадрат перед обрезкой. Тем самым показывая нам его область проверки касаний.\n\n Второй переключатель добавляет  **.contentShape(Rectangle())**  , ограничивая проверку попаданий видимой(оранжевой) областью. Теперь нажатие кнопки увеличивает счет нажатий на нее.\n\nПолный код  доступен на GitHub  .\n\nYour browser does not support HTML5 video.\n\n## Итог ##\n\nМодификатор  **clipped()**  не влияет на область проверки касания для обрезанного вью. То же самое верно и для  clipShape(\\_:)  . Часто рекомендуется комбинировать эти модификаторы с  **.contentShape(Rectangle())**  , чтобы синхронизировать логику проверки касания с UI.\n\nОригинал статьи\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "В SwiftUI модификатор clipped() обрезает вью до своих границ, но не влияет на проверку касаний (hit testing). Это значит, что обрезанный вью все равно принимает тапы / клики за пределами видимой области. Чтобы исправить это, используйте модификатор .contentShape() вместе с .clipped(). Это ограничит область проверки касаний, сделая кнопку доступной для нажатия."}, {"request": "Тестируйте API, как профессионал. Часть 2: Как автоматизировать API с помощью 'cypress-plugin-api' / Хабр                 \n\ncypress-plugin-api  , написанный амбассадором Cypress  Филипом Хриком  (Filip Hric), представляет собой плагин для эффективного тестирования API. Представьте себе Postman, но в Cypress; этот плагин выводит на печать всю информацию о вызове API в пользовательском интерфейсе приложения Cypress, обеспечивая несколько преимуществ:\n\nВ  `cypress-plugin-api`  команда  `cy.api()`  работает также как  `cy.request()`  . Основное отличие заключается в том, что помимо вызова вашего API,  `cy.api()`  также печатает информацию о вызове API в вашем Cypress Test Runner.\n\n Всю эту информацию можно просмотреть в виде  time-travel  (реверсивная отладка) snapshots.\n\n Также формируется простая таблица для просмотра файлов cookie, сворачивания объектов данных JSON и массива, а также цветового кодирования методов в представлении пользовательского интерфейса и на таймлайне (временной шкале)\n\n_Самое важное:_  `cy.api()`  использует  `cy.request()`  в фоновом режиме. Это означает, что вы получаете ту же функциональность плюс визуальный пользовательский интерфейс!\n\n### Давайте вместе установим плагин cypress-plugin-api ###\n\n**Шаг 1**\n\nУстновите  плагин,  используя npm или yarn.\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnpm i cypress-plugin-api\n# or\nyarn add cypress-plugin-api\n\n```\n\nПосле установки плагина API вы можете увидеть его в файле package.json:\n\n**Шаг 2**\n\nДалее добавьте плагин   `cypress/support/e2e.js`  в файл:\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timport 'cypress-plugin-api'\n// or\nrequire('cypress-plugin-api')\n\n```\n\nВаши e2e.js файлы будут выглядеть так:\n\n**Шаг 3**\n\nСоздайте плагин  `cypress_plugin_api.cy.js`  с помощью методов (GET, POST, PUT, DELETE).\n\nДля данного обзора я беру различные примеры методов API из этого ресурса:  https://reqres.in/  .\n\n**GET Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"GET API testing Using Cypress API Plugin\", () => {\n cy.api(\"GET\", \"https://reqres.in/api/users?page=2\").should((response) => {\n   expect(response.status).to.eq(200);\n });\n});\n\n```\n\n**POST Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"POST API testing Using Cypress API Plugin\", () => {\n cy.api(\"POST\", \"https://reqres.in/api/users\", {\n   name: \"morpheus\",\n   job: \"leader\",\n }).should((response) => {\n   expect(response.status).to.eq(201);\n });\n});\n\n```\n\n**PUT Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"PUT API testing Using Cypress API Plugin\", () => {\n cy.api(\"PUT\", \"https://reqres.in/api/users/2\", {\n   name: \"morpheus\",\n   job: \"zion resident\",\n }).should((response) => {\n   expect(response.status).to.eq(200);\n });\n});\n\n```\n\n**DELETE Запрос**\n\n```\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tit(\"DELETE API testing Using Cypress API Plugin\", () => {\n cy.api(\"DELETE\", \"https://reqres.in/api/users/2\").should((response) => {\n   expect(response.status).to.eq(204);\n });\n});\n\n```\n\n### Отчет о выполнении тестового кейса API ###\n\nНа скриншоте ниже мы видим данные Body, Response, Headers и Cookies, отображенные в пользовательском интерфейсе приложения Cypress. Ранее для просмотра этой информации нам приходилось нажимать на кнопку 'inspect', но теперь у нас есть пользовательский интерфейс, который позволяет нам легко получить к ней доступ.\n\n**GET Запрос**\n\n**POST Запрос**\n\n**PUT Запрос**\n\n**DELETE Запрос**\n\nВ завершение приглашаем всех желающих на открытый урок «Автоматизация API + удобные отчеты», который пройдет 24 марта в преддверии старта курса \"JavaScript QA Engineer\".\n\nЗаписаться на бесплатный урок\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "Автор представляет плагин cypress-plugin-api, который позволяет эффективно тестировать API в среде Cypress. Плагин позволяет выводить информацию о вызове API в пользовательском интерфейсе Cypress Test Runner и предоставляет возможность просмотра данных в виде time-travel snapshots. Также плагин формирует удобную таблицу для просмотра файлов cookie и цветовое кодирование методов. Чтобы установить плагин, нужно добавить его в файл package.json и использовать методы GET, POST, PUT и DELETE для тестирования различных API запросов. Плагин предоставляет отчет о выполнении тестовых кейсов API, где отображаются данные Body, Response, Headers и Cookies."}, {"request": "Расширение и перемещение ансамбля ZooKeeper / Habr             \n\n17-10-2021\nВсех приветствую! Недавно перед нашей командой DBA предстала задача по перемещению ансамбля ZooKeeper на другие сервера. Проблема оказалась в том, что в просторах интернета нет доступного руководства для ZooKeeper версии 3.6.2 и выше. Нашлось руководство для версии 3.4.5, но таким образом расширить и переместить наш ансамбль мы не решились. Может появиться вопрос: Почему нельзя просто переместить файлы на другой сервер и запустить ансамбль там? Наш ансамбль хранит данные по слиянию и реплицированию данных кластера Clickhouse. План работы У нас имеется ансамбль из 3 инстансов, расположенных на 3 отдельных серверах, и нам предоставили другие 3 сервера для переезда. С целью поддержания кворума мы нашли 1 дополнительный временный сервер. Первым делом мы расширим кластер до 7 инстансов: 3 (id: 1, 2, 3) +1 (id: 4) + 3 (id: 5, 6, 7) После расширения и синхронизации, выводим из ансамбля ненужные инстансы. Останутся только id: 5, 6, 7. Расширение существующего ансамбля В официальной документации описан метод расширения, но мы хотим это наглядно показать. Наш ансамбль работает на CentOS 7 и состоит из 3 инстансов: server.1=zk-1:2888:3888 server.2=zk-2:2888:3888 server.3=zk-3:2888:3888 Если у Вас нет в конфигурационном файле нет reconfigEnabled=true то, необходимо перезапустить Ваш ансамбль с данной строкой. Так же в файл $ZK_HOME/bin/zkEnv.sh можете добавить: Dzookeeper.skipACL=yes export SERVER_JVMFLAGS=\"$SERVER_JVMFLAGS -Dzookeeper.skipACL=yes\" данные строки понадобятся при выполнении динамической реконфигурации ансамбля. После перезапуска ансамбля, мы можем приступать к расширению. Для этого подготовим все необходимое: Загрузим архив с apache-zookeeper (в нашем случае apache-zookeeper-3.6.2-bin.tar.gz); Распакуем и создадим пользователя ОС для ZooKeeper; Создаем директорию для файлов ZooKeeper и файл myid, который будет идентификатором инстанса. У нас уже есть 3 инстанса server.1=zk-1:2888:3888 server.2=zk-2:2888:3888 server.3=zk-3:2888:3888. Для расширения мы планируем добавить еще 4 инстанса. Поэтому myid будут содержать числа 4, 5, 6, 7; Открываем порты в firewalld; Создаем service файл. После подготовки нам понадобится $ZK_HOME/bin/zkCli.sh reconfig -add server.4=zk-4:2888:3888:participant;2181 Успешность выполнения можно проверить в $ZK_HOME/conf. Появится файл zoo.conf.dynamic.100000000 и соответствующая ссылка на данный файл в zoo.conf: dynamicConfigFile=/home/zookeeper/apache-zookeeper-3.6.2-bin/conf/zoo.conf.dynamic.100000000 Цифра после zoo.conf.dynamic. будет отличаться. Далее запускаем инстанс ZooKeeper на сервере zk-4. Данный инстанс получит такие же конфигурационные файлы. Можно следить за ходом синхронизации в логах. Такую же операцию выполняем для серверов zk-5, zk-6, zk-7. Вывод из ансамбля Для вывода zk-1, zk-2, zk-3, zk-4 из ансамбля, воспользуемся тем же $ZK_HOME/bin/zkCli.sh reconfig -remove 1 reconfig -remove 2 reconfig -remove 3 reconfig -remove 4 После выполнения, Вы так же увидите как поменяется файл zoo.conf.dynamic.XXXXXXX. Теперь можно выключить сервис ZooKeeper на серверах zk-1, zk-2, zk-3, zk-4. Не забудьте убрать из автозапуска. Итого Итого мы с помощью расширения новыми инстансами и выводом старых, переместили ансамбль из серверов zk-1, zk-2, zk-3 на сервера zk-5, zk-6, zk-7. Дополнительно советую добавить в zoo.conf и открыть 7000 порт metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider Таким образом, у Вас будет возможность собирать метрики через Prometheus.\n\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "Автор статьи рассказывает о проблеме перемещения ансамбля ZooKeeper на другие сервера. Он объясняет, что отсутствует доступное руководство для версии 3.6.2 и выше, и предлагает свой собственный метод расширения и перемещения ансамбля. Автор пошагово описывает этот метод, включая подготовку серверов, настройку конфигурационных файлов и проведение динамической реконфигурации. В конечном итоге, ансамбль успешно перемещается на новые серверы. Автор также дает дополнительный совет по настройке метрик через Prometheus."}, {"request": "Реально честные светильники Армстронг, тестирование 2 образцов от Isvet / Хабр                 \n\nНа отечественном рынке светодиодной продукции представлено множество моделей светильников. Большинство из них обещают высокие показатели светового потока. В реальности больше половины имеют завышенные харастеристики.\n\nВ тестировании участвуют 2 модели светодиодных светильников для потолков Армстронг. Проведём замеры реальных характеристик светового потока, цветовой температуры, мощности.\n\nСветильники предоставлены компанией\nISVET\n, полное обозначение:\n\n1. FP-UPL-102-D-36W-6K\n\n2. FP-UPL-103-36W-6К\n\n## Характеристики ##\n\nВ офисных светодиодных светильниках ISVET установлено 4 линейки со светодиодами, у UPL102 установлено 180 светодиодов, UPL102 112 светодиодов. Все диодные линейки подключены последовательно, за счет этого напряжение на входе высокое, и сила тока небольшая. Например у UPL103 источник питания на 360 миллиампер и напряжение 90 вольт.\n\n|  |  |  |\n| --- | --- | --- |\n|  Параметр  |  UPL 102  |  UPL 103  |\n|  Мощность  |  36W  |  36W  |\n|  Световой поток  |  3700лм  |  3300лм  |\n|  Питание  |  150 – 265В  |\n|  Коэффициент пульсаций  |  менее 2%  |  <2%  |\n|  Цветовая температура  |  6000К  |  6000К  |\n|  Размеры  |  595 х 595 x 20 мм.  |  595 х 595 x 30 мм.  |\n|  Индекс цветопередачи CRI  |  >80  |  >80  |\n|  Срок службы  |  30.000 ч.  |  30.000 ч.  |\n|  Температура среды  |  -20° до +50°  |  -20° до +50°  |\n|  Гарантия  |   —  |   —  |\n\nНа образцах установлены рассеиватели «колотый лёд». В отличие от матовых рассеивателей, «колотый лёд» обеспечивает светопропускаемость выше в 2-3 раза.\n\nКорпус образцов от компании ISVET выполнен из тонкой стали, общая толщина составляет 20мм. Это позволяет устанавливать светильники армстронг не только встраиваемым, но и накладным способом.\n\n## Приборы ##\n\n## Мощность ##\n\nЗамеры энергопотребления показали полное соответствие заявленным значениям. Реальная мощность составила 36 Ватт.\n\n|  |  |  |\n| --- | --- | --- |\n|   —  |  Заявлено  |  Измерено  |\n|  UPL 102  |  36w  |  36вт  |\n|  UPL 103  |  36w  |  36вт  |\n\n## Световой поток ##\n\nДля измерения светового потока использовался фотометрический куб, рассчитанный на измерение светодиодных светильников для потолков армстронг. Размеры 60х60х60 см. Предварительно образцы прогревались в течение 1 часа.\n\n|  |  |  |\n| --- | --- | --- |\n|   —  |  Заявлено  |  Измерено  |\n|  UPL 102  |  3700лм  |  4120лм  |\n|  UPL 103  |  3300лм  |  3290лм  |\n\nСветовой поток UPL102 оказался выше заявленного производителем на 420 люмен, что составляет 11%.\n\nКоэффициент пульсаций светового потока составляет 1%, то есть пульсации полностью отсутствуют. Источник питания хорошо справляется с нагрузкой.\n\n## Цветовая температура ##\n\nЗамеры цветовой температуры проводим спектрометром UPRtek MK350. Результаты замеров немного ниже заявленных. Если учитывать допустимую погрешность на производстве и погрешность измерительного прибора, то результат очень близки к заявленным.\n\n|  |  |  |\n| --- | --- | --- |\n|   —  |  Заявлено  |  Измерено  |\n|  UPL 102  |  6000К  |  5612К  |\n|  UPL 103  |  6000К  |  5830К  |\n\n## Где купить? ##\n\nПриобрести светодиодные светильники iSvet UPL 102 и UPL 103 можно на\nофициальном сайте производителя\n\n## Итоги ##\n\nРезультаты тестирования показали высокое качество светильников от бренда ISVET. Световой поток и цветовая температура соответствуют заявленным параметрам. Источник питания справляется нагрузкой и обеспечивает коэффициент пульсаций ниже 1%.\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "Тестирование светодиодных светильников моделей UPL 102 и UPL 103 от компании ISVET показало их высокое качество. Световой поток и цветовая температура соответствуют заявленным характеристикам, а источник питания обеспечивает низкий коэффициент пульсаций."}, {"request": "Верстка без float'ов / Habr                        \n\nСуществует много разных способов css разметки. Некоторые базируются на абсолютном позиционировании, другие используют float'ы. Первый метод плохо поддерживает «резиновость» макета, тогда как второй это неплохой способ разметки.\n\nНо, как и многие мощные инструменты, float'ы имеют свои изъяны. Для начала, верстка на основе float'ов не такая простая к пониманию, а также float'ы есть источником многих багов (в основном в ИЕ), что делает их не идеальным вариантом в погоне за кроссбраузерностью.\n\nИтак, речь далее пойдет о\n\nсемантически корректном методе верстки.\n\n**Начнем с обычной разметки (основанной на div'ах)**\n\n> `  Header`\n>\n>\n\n  `Body`\n>\n>\n\n          `Section 1`\n>\n>\n\n      `Section 2`\n>\n>\n\n      `Section 3`\n>\n>\n\n    \n>\n>\n\n  \n>\n>\n\n  `Footer`\n\nНо div'ы не могут отобразить структуру документа, для этого семантически более подходят списки, потому как они, в отличие от div'ов передают иерархию и связи, которые присутствуют между элементами.\n\n> `Header`\n>\n> `Body`\n>\n>\n>\n> `Section 1`\n>\n> `Section 2`\n>\n> `Section 3`\n>\n>\n>\n>\n>\n> `Footer`\n\n**Использование CSS стилей**\n\nДля «хороших» браузеров, все достаточно прозрачно.\n\n> `* {margin:0;padding:0;}`\n>\n>\n\n#`wp {width:55em;margin:0 auto;list-style-type:none;}`\n>\n>\n\n#`bd {display:table;}`\n>\n>\n\n#`doc {display:table-row;}`\n>\n>\n\n#`s1,#s2,#s3 {display:table-cell;}`\n\n**Стили для IE**\n\nВ IE LI имеют значение display равным inline-block, поэтому:\n\n1. Для IE Win используем {display: inline; zoom: 1}. «zoom:1» используется для того чтобы елементы имели hasLayout-свойство. (читайте\nналичие layout\nили на хабре\nИзучаем наличие layout\n)\n\n2. Для IE Mac — {display:inline-block;float:left;}\n\nТак же нам понадобятся еще несколько дополнительных правил:\n\nvertical-align чтобы контент в LI прижимался к верху, а не к низу\n\nwidth для каждого из LI\n\n> `#s1,#s2,#s3,{display:inline;zoom:1;vertical-align:top;}`\n>\n>\n\n#`s1 {width:12em;}`\n>\n>\n\n#`s2 {width:29em;}`\n>\n>\n\n#`s3 {width:14em;}`\n>\n>\n\n`/*\\*//*/`\n>\n>\n\n#`s1,#s2,#s3 {display:inline-block;float:left;}`\n>\n>\n\n#`ft {clear:left;}`\n>\n>\n\n`/**/`\n\nCss-правила выше используют некоторые хаки, а именно:\n\nIE (IE 7 и IE Mac включительно) **не**  игнорирует правила, в которых запятая предшествует блоку объявлений\n\nIE5 Mac <a href=« www.stopdesign.com/examples/ie5mac-bpf » title«фильтр»>фильтр\n\nТак как IE 5.1 имеет баги с математическими рассчетами, то нужно уменьшить ширину первого столбца, поэтому используем\ntjkdesign.com/articles/conditional\\_comments.asp\n» title«условные комментарии»>условные комментарии с условием «if lt IE 5.5000»\n\n>\n\nПо сути на этом все… Далее в статье автор рассказывает как добавить границы, а также указывает на разницу в правилах для фиксированной и резиновой верстки.\n\nМетод достаточно интересный, если отбросить поддержку морально устаревших браузеров, таких как IE5.5 и меньше, то правил станет значительно меньше. Этот метод позволяет просто и без забот решить проблему, когда нужно расстянуть float-блок (скорее всего боковой блок), чтобы он был равен главному по высоте (к примеру, если фон нужно расстянуть).\n\nНиже привожу ссылки с примерами разных разметок:\n\nФиксированная в пикселях: 210, 400, 190\n\ntjkdesign.com/articles/css-layout/?6\n» title\"\">Резиновая в %: 20, 60, 20 с мин/макс шириной (800px/1200px)\n\ntjkdesign.com/articles/css-layout/?7\n» title\"\">Резиновая в %: 20, 60, 20\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "В статье рассказывается о разных способах css разметки и особенностях использования float'ов. Автор предлагает использовать более семантически корректные методы верстки, используя списки вместо div'ов. Он также представляет CSS стили для хороших браузеров и дополнительные правила для IE. В конце статьи автор указывает на преимущества этого метода и предлагает примеры разных разметок."}, {"request": "PHP: проблема с timestamp в DateTime / Habr                        \n\n18-01-2009\nМногие разработчики на PHP используют объекты класса DateTime. Об удобствах его я писать не буду, тем более на Хабре уже была статья об этом классе, не об этом речь. Все бы хорошо, да есть у данного класса проблемка, с которой я столкнулся только недавно. Объект класса DateTime в PHP можно создать как стандартным методом: $date = new DateTime ( «2009-01-21» ); так и функцией date_create, входящей в состав PHP начиная с версии 5.2.0: $date = date_create ( «2009-01-21» ); Конструктор принимает как параметр строку, которая определяет дату и время, также это могут быть названия дней недели и куча других параметров, которые описаны в документации к функции strtotime. Еще есть возможность передавать в конструктор метку времени (timestamp), поместив ее после символа \"@\", к примеру, так: $date = new DateTime ( \"@1232488800\" ); Именно с этим параметром и возникли некоторые непонятки. Для вывода информации о конкретном объекте даты создадим следующую функцию: function date_info ( DateTime $date ){ echo \"<br>\" ; echo «Timestamp: » . $date -> format ( «U» ). ' - ' . $date -> format ( «d/m/Y H:i:s» ). \"<br>\" ; $tz = $date -> getTimezone (); echo «Timezone: » . $tz -> getName (). \" (Offset: \" . $date -> getOffset (). \" sec.)<br>\" ; } В ней мы выводим на экран следующие сведения: — метку времени — саму дату и время — временную зону — смещение в секундах этой самой временной зоны Создаем объекты даты и выводим информацию о нем $date1 = new DateTime ( «2009-01-21 00:00:00» ); date_info ( $date1 ); получили Timestamp: 1232488800 — 21/01/2009 00:00:00 Timezone: Europe/Helsinki (Offset: 7200 sec.) хорошо, у нас есть метка, дата и временная зона. Создадим другой объект, передадим ему в параметр название недели того же дня — «Wednesday». $date2 = new DateTime ( «Wednesday» ); date_info ( $date2 ); Так как это ближайшая среда, то дата будет той же Timestamp: 1232488800 — 21/01/2009 00:00:00 Timezone: Europe/Helsinki (Offset: 7200 sec.) Замечательно. Теперь у нас есть 2 одинаковые метки времени и совпадающие даты. Теперь внимание, создаем объект с параметром временной метки и выводим информацию о нем $date3 = new DateTime ( \"@1232488800\" ); date_info ( $date3 ); и что же мы видим: Timestamp: 1232488800 — 20/01/2009 22:00:00 Timezone: Europe/Helsinki (Offset: 7200 sec.) Метка времени осталась той же, временная зона тоже не поменялась, а вот дата и время сместились на время, соответствующие смещению временной зоны, только со знаком минус. То есть смещение как таковое у нас не сработало. Я с недоумением смотрел на результат и не мог понять, как это возможно. Заново пересмотрел документацию — вроде все правильно сделал. Решилось все, как обычно, методом научного тыка. Я подумал, а почему бы мне не применить к объекту его текущую временную зону $date -> setTimezone (new DateTimeZone ( «Europe/Helsinki» )); date_info ( $date ); и, О ЧУДО! Скрипт выдал мне нужную дату. Timestamp: 1232488800 — 21/01/2009 00:00:00 Timezone: Europe/Helsinki (Offset: 7200 sec.) Делал все эти телодвижения я в Виндовсе, стал уже грешить на нее, но попробовав в Линкусе, и получив тот же результат, кошусь в сторону разработчиков языка. Версия PHP в обеих ОСях 5.2.4, так что, возможно, в более новых версиях уже исправлено. Но кто предупрежден — тот вооружен. P.S. Я пытался устанавливать временную зону и для остальных объектов даты, но изменений это не принесло, поэтому я этого и не описывал.\n\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "В тексте рассказывается о проблеме с использованием метки времени (timestamp) в классе DateTime в PHP. Автор столкнулся с тем, что при создании объекта с указанием метки времени, дата и время объекта смещаются на время, соответствующее временной зоне. Автор находит решение проблемы, применяя к объекту текущую временную зону. В конце автор считает, что проблема может быть исправлена в более новых версиях PHP."}, {"request": "Расширение и перемещение ансамбля ZooKeeper / Habr             \n\n17-10-2021\nВсех приветствую! Недавно перед нашей командой DBA предстала задача по перемещению ансамбля ZooKeeper на другие сервера. Проблема оказалась в том, что в просторах интернета нет доступного руководства для ZooKeeper версии 3.6.2 и выше. Нашлось руководство для версии 3.4.5, но таким образом расширить и переместить наш ансамбль мы не решились. Может появиться вопрос: Почему нельзя просто переместить файлы на другой сервер и запустить ансамбль там? Наш ансамбль хранит данные по слиянию и реплицированию данных кластера Clickhouse. План работы У нас имеется ансамбль из 3 инстансов, расположенных на 3 отдельных серверах, и нам предоставили другие 3 сервера для переезда. С целью поддержания кворума мы нашли 1 дополнительный временный сервер. Первым делом мы расширим кластер до 7 инстансов: 3 (id: 1, 2, 3) +1 (id: 4) + 3 (id: 5, 6, 7) После расширения и синхронизации, выводим из ансамбля ненужные инстансы. Останутся только id: 5, 6, 7. Расширение существующего ансамбля В официальной документации описан метод расширения, но мы хотим это наглядно показать. Наш ансамбль работает на CentOS 7 и состоит из 3 инстансов: server.1=zk-1:2888:3888 server.2=zk-2:2888:3888 server.3=zk-3:2888:3888 Если у Вас нет в конфигурационном файле нет reconfigEnabled=true то, необходимо перезапустить Ваш ансамбль с данной строкой. Так же в файл $ZK_HOME/bin/zkEnv.sh можете добавить: Dzookeeper.skipACL=yes export SERVER_JVMFLAGS=\"$SERVER_JVMFLAGS -Dzookeeper.skipACL=yes\" данные строки понадобятся при выполнении динамической реконфигурации ансамбля. После перезапуска ансамбля, мы можем приступать к расширению. Для этого подготовим все необходимое: Загрузим архив с apache-zookeeper (в нашем случае apache-zookeeper-3.6.2-bin.tar.gz); Распакуем и создадим пользователя ОС для ZooKeeper; Создаем директорию для файлов ZooKeeper и файл myid, который будет идентификатором инстанса. У нас уже есть 3 инстанса server.1=zk-1:2888:3888 server.2=zk-2:2888:3888 server.3=zk-3:2888:3888. Для расширения мы планируем добавить еще 4 инстанса. Поэтому myid будут содержать числа 4, 5, 6, 7; Открываем порты в firewalld; Создаем service файл. После подготовки нам понадобится $ZK_HOME/bin/zkCli.sh reconfig -add server.4=zk-4:2888:3888:participant;2181 Успешность выполнения можно проверить в $ZK_HOME/conf. Появится файл zoo.conf.dynamic.100000000 и соответствующая ссылка на данный файл в zoo.conf: dynamicConfigFile=/home/zookeeper/apache-zookeeper-3.6.2-bin/conf/zoo.conf.dynamic.100000000 Цифра после zoo.conf.dynamic. будет отличаться. Далее запускаем инстанс ZooKeeper на сервере zk-4. Данный инстанс получит такие же конфигурационные файлы. Можно следить за ходом синхронизации в логах. Такую же операцию выполняем для серверов zk-5, zk-6, zk-7. Вывод из ансамбля Для вывода zk-1, zk-2, zk-3, zk-4 из ансамбля, воспользуемся тем же $ZK_HOME/bin/zkCli.sh reconfig -remove 1 reconfig -remove 2 reconfig -remove 3 reconfig -remove 4 После выполнения, Вы так же увидите как поменяется файл zoo.conf.dynamic.XXXXXXX. Теперь можно выключить сервис ZooKeeper на серверах zk-1, zk-2, zk-3, zk-4. Не забудьте убрать из автозапуска. Итого Итого мы с помощью расширения новыми инстансами и выводом старых, переместили ансамбль из серверов zk-1, zk-2, zk-3 на сервера zk-5, zk-6, zk-7. Дополнительно советую добавить в zoo.conf и открыть 7000 порт metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider Таким образом, у Вас будет возможность собирать метрики через Prometheus.\n\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "Статья посвящена проблеме перемещения ZooKeeper-ансамбля на другие сервера. Описывается процесс расширения кластера ZooKeeper до 7 инстансов и последующего вывода из ансамбля старых серверов. Даются рекомендации по настройке ZooKeeper для сбора метрик через Prometheus."}, {"request": "Intel Core i9-9990XE (14 ядер до 5 ГГц) будет продаваться только на закрытом аукционе / Хабр                 \n\nПо\nинформации из нескольких источников\n, Intel готовит к выпуску самый мощный десктопный процессор Core i9-9990XE — это настоящий монстр с 14 ядрами и базовой частотой 4,0 ГГц (повышается до 5,0 ГГц в турборежиме).\n\nСамое интересное, что процессор не поступит в розничную продажу, а будет продаваться только на закрытом аукционе «для системных интеграторов».\n\nИздание\n_AnandTech_\n\nпубликует\nобновлённую линейку топовых десктопных процессоров Intel, где новинка занимает первую строчку. Обратите внимание на рекордное энергопотребление и тепловыделения Core i9-9990XE в 255 Вт! Это намного больше, чем у нынешнего лидера Core i9-9980XE.\n\nКстати, если учесть рекомендованную цену последнего в \\$1979, то новинка на аукционе будет стоить гораздо больше \\$2000 за штуку. Судя по количеству ядер, i9-9990XE представляет собой максимально разогнанный вариант i9-9940X.\n\n|  |  |  |  |  |  |  |  |  |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n|   |   |  **Ядер**  |  **TDP**  |  **Частота**  |  **L3**  **(МБ)**  |  **L3 на**  **ядро**  |  **DRAM**  **DDR4**  |  **PCIe**  |\n|  **i9-9990XE**  |  **аукцион**  |  **14 / 28**  |  **255 Вт**  |  **4.0 / 5.0**  |  **?**  |  **?**  |  **2666**  |  **44**  |\n|  i9-9980XE |  \\$1979 |  18 / 36 |  165 Вт |  3.0 / 4.5 |  24.75 |  1.375 |  2666 |  44 |\n|  i9-9960X |  \\$1684 |  16 / 32 |  165 Вт |  3.1 / 4.5 |  22.00 |  1.375 |  2666 |  44 |\n|  i9-9940X |  \\$1387 |  14 / 28 |  165 Вт |  3.3 / 4.5 |  19.25 |  1.375 |  2666 |  44 |\n|  i9-9920X |  \\$1189 |  12 / 24 |  165 Вт |  3.5 / 4.5 |  19.25 |  1.604 |  2666 |  44 |\n|  i9-9900X |  \\$989 |  10 / 20 |  165 Вт |  3.5 / 4.5 |  19.25 |  1.925 |  2666 |  44 |\n|  i9-9820X |  \\$889 |  10 / 20 |  165 Вт |  3.3 / 4.2 |  16.50 |  1.650 |  2666 |  44 |\n|  i7-9800X |  \\$589 |  8 / 16 |  165 Вт |  3.8 / 4.5 |  16.50 |  2.031 |  2666 |  44 |\n\nЗакрытые аукционы по продаже Core i9-9990XE планируется проводить раз в квартал, а первый аукцион назначен на третью неделю 2019 года, то есть на текущую неделю.\n\n_AnandTech_\nотмечает, что на 1,3 вольтах на чип придётся подавать 420 А (по 30 ампер на ядро), а TDP возрастает до 546 Вт.\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "Intel готовит к выпуску новый процессор Core i9-9990XE с 14 ядрами и базовой частотой 4,0 ГГц. Процессор не поступит в розничную продажу, а будет продаваться только на закрытом аукционе для системных интеграторов."}, {"request": "Реально честные светильники Армстронг, тестирование 2 образцов от Isvet / Хабр                 \n\nНа отечественном рынке светодиодной продукции представлено множество моделей светильников. Большинство из них обещают высокие показатели светового потока. В реальности больше половины имеют завышенные харастеристики.\n\nВ тестировании участвуют 2 модели светодиодных светильников для потолков Армстронг. Проведём замеры реальных характеристик светового потока, цветовой температуры, мощности.\n\nСветильники предоставлены компанией\nISVET\n, полное обозначение:\n\n1. FP-UPL-102-D-36W-6K\n\n2. FP-UPL-103-36W-6К\n\n## Характеристики ##\n\nВ офисных светодиодных светильниках ISVET установлено 4 линейки со светодиодами, у UPL102 установлено 180 светодиодов, UPL102 112 светодиодов. Все диодные линейки подключены последовательно, за счет этого напряжение на входе высокое, и сила тока небольшая. Например у UPL103 источник питания на 360 миллиампер и напряжение 90 вольт.\n\n|  |  |  |\n| --- | --- | --- |\n|  Параметр  |  UPL 102  |  UPL 103  |\n|  Мощность  |  36W  |  36W  |\n|  Световой поток  |  3700лм  |  3300лм  |\n|  Питание  |  150 – 265В  |\n|  Коэффициент пульсаций  |  менее 2%  |  <2%  |\n|  Цветовая температура  |  6000К  |  6000К  |\n|  Размеры  |  595 х 595 x 20 мм.  |  595 х 595 x 30 мм.  |\n|  Индекс цветопередачи CRI  |  >80  |  >80  |\n|  Срок службы  |  30.000 ч.  |  30.000 ч.  |\n|  Температура среды  |  -20° до +50°  |  -20° до +50°  |\n|  Гарантия  |   —  |   —  |\n\nНа образцах установлены рассеиватели «колотый лёд». В отличие от матовых рассеивателей, «колотый лёд» обеспечивает светопропускаемость выше в 2-3 раза.\n\nКорпус образцов от компании ISVET выполнен из тонкой стали, общая толщина составляет 20мм. Это позволяет устанавливать светильники армстронг не только встраиваемым, но и накладным способом.\n\n## Приборы ##\n\n## Мощность ##\n\nЗамеры энергопотребления показали полное соответствие заявленным значениям. Реальная мощность составила 36 Ватт.\n\n|  |  |  |\n| --- | --- | --- |\n|   —  |  Заявлено  |  Измерено  |\n|  UPL 102  |  36w  |  36вт  |\n|  UPL 103  |  36w  |  36вт  |\n\n## Световой поток ##\n\nДля измерения светового потока использовался фотометрический куб, рассчитанный на измерение светодиодных светильников для потолков армстронг. Размеры 60х60х60 см. Предварительно образцы прогревались в течение 1 часа.\n\n|  |  |  |\n| --- | --- | --- |\n|   —  |  Заявлено  |  Измерено  |\n|  UPL 102  |  3700лм  |  4120лм  |\n|  UPL 103  |  3300лм  |  3290лм  |\n\nСветовой поток UPL102 оказался выше заявленного производителем на 420 люмен, что составляет 11%.\n\nКоэффициент пульсаций светового потока составляет 1%, то есть пульсации полностью отсутствуют. Источник питания хорошо справляется с нагрузкой.\n\n## Цветовая температура ##\n\nЗамеры цветовой температуры проводим спектрометром UPRtek MK350. Результаты замеров немного ниже заявленных. Если учитывать допустимую погрешность на производстве и погрешность измерительного прибора, то результат очень близки к заявленным.\n\n|  |  |  |\n| --- | --- | --- |\n|   —  |  Заявлено  |  Измерено  |\n|  UPL 102  |  6000К  |  5612К  |\n|  UPL 103  |  6000К  |  5830К  |\n\n## Где купить? ##\n\nПриобрести светодиодные светильники iSvet UPL 102 и UPL 103 можно на\nофициальном сайте производителя\n\n## Итоги ##\n\nРезультаты тестирования показали высокое качество светильников от бренда ISVET. Световой поток и цветовая температура соответствуют заявленным параметрам. Источник питания справляется нагрузкой и обеспечивает коэффициент пульсаций ниже 1%.\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "Тестирование двух моделей светодиодных светильников Армстронг от компании ISVET показало, что заявленные характеристики светового потока и цветовой температуры соответствуют реальным показателям. Источник питания обеспечивает коэффициент пульсаций ниже 1%. Светильники можно приобрести на официальном сайте производителя."}, {"request": "Logging — библиотека для удобного ведения логов в Python / Хабр                 \n\nВ любой разработке приходится рано или поздно вести логи, ведь не отдашь же заказчику программу где отладочные сообщения выводятся с помощью print, да и в дальнейшем если у заказчика что то пойдет не так то можно просто попросит показать лог и понять в чем проблема(в большинстве случаев), так вот в питоне есть очень мощная и удобная библиотека и дальше я попробую про нее рассказать.\n\nДля начала подключим библиотеку и попробуем вывести на консоль сообщения разного типа:\n\n```\n#log.py\n#!/usr/bin/python\n# -\\*- coding: utf-8 -\\*-\n\nimport  logging\n\n# Сообщение отладочное\nlogging.debug( u'This is a debug message'  )\n# Сообщение информационное\nlogging.info( u'This is an info message'  )\n# Сообщение предупреждение\nlogging.warning( u'This is a warning'  )\n# Сообщение ошибки\nlogging.error( u'This is an error message'  )\n# Сообщение критическое\nlogging.critical( u'FATAL!!!'  )\n\n```\n\nПри выводе мы получаем:\n\n```\nWARNING:root:This is a warning\nERROR:root:This is an error message\nCRITICAL:root:FATAL!!!\n\n```\n\nКак мы видим то при выводе мы получаем все кроме сообщений отладки и информационных, для того что бы мы могли их увидеть нужно в настройки логера передать уровень выводимых ошибок:\n\n```\nlogging.basicConfig(level = logging.DEBUG)\n\n```\n\nСразу хочу оговориться что конфигурационые параметры должны передаваться до первого вызова вывода ошибки, вот код:\n\n```\n#log.py\n#!/usr/bin/python\n# -\\*- coding: utf-8 -\\*-\n\nimport  logging\n\nlogging.basicConfig(level = logging.DEBUG)\n\n# Сообщение отладочное\nlogging.debug( u'This is a debug message'  )\n# Сообщение информационное\nlogging.info( u'This is an info message'  )\n# Сообщение предупреждение\nlogging.warning( u'This is a warning'  )\n# Сообщение ошибки\nlogging.error( u'This is an error message'  )\n# Сообщение критическое\nlogging.critical( u'FATAL!!!'  )\n\n```\n\nТеперь после вывода мы получим все сообщения:\n\n```\nDEBUG:root:This is a debug message\nINFO:root:This is an info message\nWARNING:root:This is a warning\nERROR:root:This is an error message\nCRITICAL:root:FATAL!!!\n\n```\n\nНо все равно как то скудно выглядит вывод из него мало чего поймешь, для это так же в конфиге логера можно задать формат выводимого сообщения, посмотреть все атрибуты можно (\nвот здесь\n):\n\n```\nlogging.basicConfig( format  = u'%(filename)s[LINE:%(lineno)d]# %(levelname)-8s [%(asctime)s] %(message)s' , level = logging.DEBUG)\n\n```\n\nтеперь после вывода мы получаем вот такие сообщения:\n\n```\n\nlog.py[LINE:33] # DEBUG [2012-05-25 00:11:58,466] This is a debug message\nlog.py[LINE:34] # INFO [2012-05-25 00:11:58,466] This is an info message\nlog.py[LINE:35] # WARNING [2012-05-25 00:11:58,466] This is a warning\nlog.py[LINE:36] # ERROR [2012-05-25 00:11:58,467] This is an error message\nlog.py[LINE:37] # CRITICAL [2012-05-25 00:11:58,467] FATAL!!!\n\n```\n\nУже что то больше похожее на логи и видно имя файла и строка в которой вызванно сообщение, но выводить их во время работы хорошо когда идет разработка ну а при сдаче проекта лучше их писать в файл, так давайте запишем их туда, для этого так же в конфигурации предусмотрен параметр для того что бы указать куда будем писать лог:\n\n```\n\nlogging.basicConfig( format  = u'%(levelname)-8s [%(asctime)s] %(message)s' , level = logging.DEBUG, filename = u'mylog.log' )\n\n```\n\nтеперь логи будут писать в файл указанный в параметре filename, на самом деле у этого логера очень много возможностей я показал лишь те которые нужны для начала работы с логером более подробную информацию можно прочитать на офф. сайте\ndocs.python.org/library/logging.html\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "В тексте рассказывается о библиотеке logging в Python, которая предоставляет мощный инструмент для ведения логов в разработке. Библиотека позволяет настраивать уровни вывода ошибок, задавать формат выводимых сообщений и записывать их в файл."}, {"request": "Молниеносный JSON в Ruby on Rails / Хабр                                                             \n\n28-09-2012\nВывод результата в JSON достаточно прост в Rails: render json: @statuses Это работает отлично, если нужно вывести небольшое количество записей. Но что случится, если нам потребуется вывести сразу 10'000 записей? Производительность серьезно просядет, а самыми затратными по времени окажутся сериализация JSON и операции с базой данных. Включайте только необходимые атрибуты Первое очевидное решение — генерировать JSON только с необходимыми нам атрибутами, т.е.: render json: @statuses, methods: [:latitude, :longitude, :timestamp, :virtual_odometer] Отфильтрованный JSON даст нам более 20% прироста производительности: default 5.940000 0.080000 6.020000 ( 6.094221) attrs 4.820000 0.010000 4.830000 ( 4.932337) Делайте выборку только необходимых полей Второе решение — забирать из базы не все, а только необходимые нам поля. render json: @statuses.select([:latitude, :longitude, :timestamp, :virtual_odometer]) Это поможет нам избежать передачи огромного количества лишних данных из базы в приложение и даст нам 2х прирост скорости: default 5.940000 0.080000 6.020000 ( 6.094221) attrs 4.820000 0.010000 4.830000 ( 4.932337) select 2.170000 0.020000 2.190000 ( 2.222277) Не инициализируйте объекты ActiveRecord, если это возможно Давайте реализуем метод, который будет возвращать «молниеносный» массив хэшей вместо объектов ActiveRecord: def self.lightning connection.select_all(select([:latitude, :longitude, :timestamp, :virtual_odometer]).arel).each do |attrs| attrs.each_key do |attr| attrs[attr] = type_cast_attribute(attr, attrs) end end end Это работает также как метод pluck, но возвращает массив хэшей, а не массив значений одного поля. Вызовем наш новый метод в контроллере: render json: @statuses.lightning Использование легковесных хэшей ускоряет создание JSON еще в 2 раза: default 5.940000 0.080000 6.020000 ( 6.094221) attrs 4.820000 0.010000 4.830000 ( 4.932337) select 2.170000 0.020000 2.190000 ( 2.222277) lightning 1.120000 0.010000 1.130000 ( 1.148763) Используйте самый быстрый дампер JSON На текущий момент доступно несколько библиотек JSON: JSON — gem JSON по-умолчанию (+ C-расширения, поставляется вместе с Ruby 1.9) Yajl — Yet Another JSON Library (автор Brian Lopez) Oj — Optimized JSON (автор Peter Ohler) Хорошая идея использовать самую быструю из них: json 0.810000 0.020000 0.830000 ( 0.841307) yajl 0.760000 0.020000 0.780000 ( 0.809903) oj 0.640000 0.010000 0.650000 ( 0.666230) Так что мы выбираем Oj дампер: render json: Oj.dump(@statuses.lightning, mode: :compat) Обобщенные результаты теста: user system total real default 5.940000 0.080000 6.020000 ( 6.094221) attrs 4.820000 0.010000 4.830000 ( 4.932337) select 2.170000 0.020000 2.190000 ( 2.222277) lightning 1.120000 0.010000 1.130000 ( 1.148763) json 0.810000 0.020000 0.830000 ( 0.841307) yajl 0.760000 0.020000 0.780000 ( 0.809903) oj 0.640000 0.010000 0.650000 ( 0.666230)\n\n\nОбобщение должно быть: связным по смыслу; понятным; без повторений; грамматически правильным; конкретным; законченным. Нужно давать четкие, краткие и прямые ответы. Обобщение должно занимать ровно один абзац. За качественное обобщение получишь чаевые до 200 долларов. Очень важно, чтобы обобщение было сделано правильно. На кону несколько жизней.\"", "response": "В статье рассматривается вопрос производительности при выводе больших объемов данных в формате JSON в Ruby on Rails. Автор предлагает несколько способов оптимизации этого процесса: выборка только необходимых атрибутов, использование легковесных хэшей вместо объектов ActiveRecord и выбор самого быстрого дампера JSON. В результате, время генерации JSON сокращается в несколько раз."}]